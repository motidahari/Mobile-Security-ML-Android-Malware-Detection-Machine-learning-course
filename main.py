from sklearn.exceptions import ConvergenceWarning
from sklearn.model_selection import train_test_split
from setting import config
from utils import get_random_number, load_data, count_apps
from classification_utils import preprocess_data
from classification import train_modelGradientBoostingClassifier, evaluate_model,\
    train_modelDecisionTreeClassifier, train_modelKNeighborsClassifier,\
    train_modelLogisticRegression, train_modelLinearSVC
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.simplefilter(action='ignore', category=ConvergenceWarning)

# need to
global c_val, epsilon_val, test_size_val, random_state_val
global c_val_max, epsilon_val_max, random_state_val_max
global accuracy_max, precision_max, recall_max
global num_benign_apps, num_malicious_apps


def initialization(malicious_count, benign_count):
    test_size_val = 0.1  # Static 0.1
    c_val = 0.021  # 1.0
    epsilon_val = 1e-3

    random_state_val = 0
    c_val_max = 0
    epsilon_val_max = 0
    test_size_val_max = 0
    random_state_val_max = random_state_val

    accuracy_max = 0
    precision_max = 0
    recall_max = 0
    return test_size_val, c_val, epsilon_val, random_state_val,\
        c_val_max, epsilon_val_max, test_size_val_max,\
        random_state_val_max, accuracy_max, precision_max, recall_max


def print_best_model(models):
    best_recall = 0
    best_accuracy = 0
    best_precision = 0
    best_model_name = None
    for model_name, results in models.items():
        if results["recall"] > best_recall and results["accuracy"] > best_accuracy and results["precision"] > best_precision:
            best_recall = results["recall"]
            best_accuracy = results["accuracy"]
            best_precision = results["precision"]
            best_model_name = model_name
    if best_model_name:
        print("Model with highest recall, precision and accuracy:")
        print("Model Name: ", best_model_name)
        print(f"Accuracy: {best_accuracy:.3f}")
        print(f"Precision: {best_precision:.3f}")
        print(f"Recall: {best_recall:.3f}")
        for key, value in models[best_model_name].items():
            if key not in ["accuracy", "precision", "recall"]:
                print(key, ": ", value)
    else:
        print("No models were provided.")


def printResults(results):
    result = {}

    for model in results.keys():
        print(f'Model Name: {model}')
        for data in results[model].keys():
            # print('data', data)
            # print('results[model][data]', results[model][data])
            print(f'\t{data}: {results[model][data]:.3f}')
        print()

    print_best_model(results)


def main():
    """"
     This is the main function that executes the entire process of loading the data, preprocessing it,
     training a model, and evaluating its performance. It also allows for the classification of a new APK.

    Inputs:
        None.
    Returns:
        None.
    """

    path = config['apksResultJsonPath']

    # Load data
    df, malicious_count, benign_count = load_data(
        path)

    df = df.rename(columns={'label': 'class'})

    # Split data into features and labels
    X = df.drop(columns=['class'])
    y = df['class']

    test_size_val, c_val, epsilon_val, random_state_val,\
        c_val_max, epsilon_val_max, test_size_val_max,\
        random_state_val_max, accuracy_max, precision_max, recall_max = initialization(
            malicious_count, benign_count)

    # Preprocess data
    X_scaled, y_encoded = preprocess_data(X, y)

    # Optimization for results
    # for x in range(1, 2):

    #     # Random c and epsilon and test_size
    #     test_size_val = get_random_number(0, 1, isInt=False)  # Static 0.1
    #     c_val = get_random_number(1, 100)

    # Split data into training and test sets
    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y_encoded, test_size=test_size_val, shuffle=True)

    print('X_train', X_train)
    print('X_test', X_test)
    print('y_train', y_train)
    print('y_test', y_test)
    print()

    # Train model
    results = {}

    modelGradientBoostingClassifier = train_modelGradientBoostingClassifier(
        X_train, y_train, n_estimators=50, learning_rate=50, random_state_val=random_state_val)
    accuracy, precision, recall = evaluate_model(
        modelGradientBoostingClassifier, X_test, y_test)

    results['modelGradientBoostingClassifier'] = {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'n_estimators': 50,
        'learning_rate': 50,
        'random_state_val': random_state_val
    }

    modelDecisionTreeClassifier = train_modelDecisionTreeClassifier(
        X_train, y_train, max_depth=100000000000000000, random_state_val=random_state_val)
    accuracy, precision, recall = evaluate_model(
        modelDecisionTreeClassifier, X_test, y_test)

    results['modelDecisionTreeClassifier'] = {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'max_depth': 100000000000000000,
        'random_state_val': random_state_val
    }

    KNeighborsClassifier = train_modelKNeighborsClassifier(
        X_train, y_train, n_neighbors=5)
    accuracy, precision, recall = evaluate_model(
        KNeighborsClassifier, X_test, y_test)

    results['KNeighborsClassifier'] = {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'n_neighbors': 5,
    }

    modelLogisticRegression = train_modelLogisticRegression(X_train, y_train, C=c_val,
                                                            epsilon=epsilon_val, random_state_val=random_state_val)
    accuracy, precision, recall = evaluate_model(
        modelLogisticRegression, X_test, y_test)
    results['modelLogisticRegression'] = {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'C': c_val,
        'epsilon': epsilon_val,
        'random_state_val': random_state_val
    }

    modelLinearSVC = train_modelLinearSVC(X_train, y_train, C=c_val,
                                          epsilon=epsilon_val, random_state_val=random_state_val)
    accuracy, precision, recall = evaluate_model(
        modelLinearSVC, X_test, y_test)
    results['modelLinearSVC'] = {
        'accuracy': accuracy,
        'precision': precision,
        'recall': recall,
        'C': c_val,
        'epsilon': epsilon_val,
        'random_state_val': random_state_val
    }
    printResults(results)


if __name__ == '__main__':
    main()
